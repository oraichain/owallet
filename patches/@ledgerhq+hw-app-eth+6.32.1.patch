diff --git a/node_modules/@ledgerhq/hw-app-eth/lib-es/Eth.d.ts b/node_modules/@ledgerhq/hw-app-eth/lib-es/Eth.d.ts
index c77df2e..0d3521c 100644
--- a/node_modules/@ledgerhq/hw-app-eth/lib-es/Eth.d.ts
+++ b/node_modules/@ledgerhq/hw-app-eth/lib-es/Eth.d.ts
@@ -36,14 +36,14 @@ export default class Eth {
     constructor(transport: Transport, scrambleKey?: string, loadConfig?: LoadConfig);
     /**
      * get Ethereum address for a given BIP 32 path.
-     * @param path a path in BIP 32 format
+     * @param paths a path in BIP 32 format
      * @option boolDisplay optionally enable or not the display
      * @option boolChaincode optionally enable or not the chaincode request
      * @return an object with a publicKey, address and (optionally) chainCode
      * @example
      * eth.getAddress("44'/60'/0'/0/0").then(o => o.address)
      */
-    getAddress(path: string, boolDisplay?: boolean, boolChaincode?: boolean): Promise<{
+    getAddress(paths: number[], boolDisplay?: boolean, boolChaincode?: boolean): Promise<{
         publicKey: string;
         address: string;
         chainCode?: string;
@@ -51,7 +51,7 @@ export default class Eth {
     /**
      * You can sign a transaction and retrieve v, r, s given the raw transaction and the BIP 32 path of the account to sign.
      *
-     * @param path: the BIP32 path to sign the transaction on
+     * @param paths: the BIP32 path to sign the transaction on
      * @param rawTxHex: the raw ethereum transaction in hexadecimal to sign
      * @param resolution: resolution is an object with all "resolved" metadata necessary to allow the device to clear sign information. This includes: ERC20 token information, plugins, contracts, NFT signatures,... You must explicitly provide something to avoid having a warning. By default, you can use Ledger's service or your own resolution service. See services/types.js for the contract. Setting the value to "null" will fallback everything to blind signing but will still allow the device to sign the transaction.
      * @example
@@ -61,7 +61,7 @@ export default class Eth {
      const result = eth.signTransaction("44'/60'/0'/0/0", tx, resolution);
      console.log(result);
      */
-    signTransaction(path: string, rawTxHex: string, resolution?: LedgerEthTransactionResolution | null): Promise<{
+    signTransaction(paths: number[], rawTxHex: string, resolution?: LedgerEthTransactionResolution | null): Promise<{
         s: string;
         v: string;
         r: string;
@@ -69,7 +69,7 @@ export default class Eth {
     /**
      * Helper to get resolution and signature of a transaction in a single method
      *
-     * @param path: the BIP32 path to sign the transaction on
+     * @param paths: the BIP32 path to sign the transaction on
      * @param rawTxHex: the raw ethereum transaction in hexadecimal to sign
      * @param resolutionConfig: configuration about what should be clear signed in the transaction
      * @param throwOnError: optional parameter to determine if a failing resolution of the transaction should throw an error or not
@@ -78,7 +78,7 @@ export default class Eth {
      const result = eth.clearSignTransaction("44'/60'/0'/0/0", tx, { erc20: true, externalPlugins: true, nft: true});
      console.log(result);
      */
-    clearSignTransaction(path: string, rawTxHex: string, resolutionConfig: ResolutionConfig, throwOnError?: boolean): Promise<{
+    clearSignTransaction(paths: number[], rawTxHex: string, resolutionConfig: ResolutionConfig, throwOnError?: boolean): Promise<{
         r: string;
         s: string;
         v: string;
diff --git a/node_modules/@ledgerhq/hw-app-eth/lib-es/Eth.js b/node_modules/@ledgerhq/hw-app-eth/lib-es/Eth.js
index ae8d87d..b38d042 100644
--- a/node_modules/@ledgerhq/hw-app-eth/lib-es/Eth.js
+++ b/node_modules/@ledgerhq/hw-app-eth/lib-es/Eth.js
@@ -105,15 +105,14 @@ var Eth = /** @class */ (function () {
     };
     /**
      * get Ethereum address for a given BIP 32 path.
-     * @param path a path in BIP 32 format
+     * @param paths a path in BIP 32 format
      * @option boolDisplay optionally enable or not the display
      * @option boolChaincode optionally enable or not the chaincode request
      * @return an object with a publicKey, address and (optionally) chainCode
      * @example
      * eth.getAddress("44'/60'/0'/0/0").then(o => o.address)
      */
-    Eth.prototype.getAddress = function (path, boolDisplay, boolChaincode) {
-        var paths = splitPath(path);
+    Eth.prototype.getAddress = function (paths, boolDisplay, boolChaincode) {        
         var buffer = Buffer.alloc(1 + paths.length * 4);
         buffer[0] = paths.length;
         paths.forEach(function (element, index) {
@@ -141,7 +140,7 @@ var Eth = /** @class */ (function () {
     /**
      * You can sign a transaction and retrieve v, r, s given the raw transaction and the BIP 32 path of the account to sign.
      *
-     * @param path: the BIP32 path to sign the transaction on
+     * @param paths: the BIP32 path to sign the transaction on
      * @param rawTxHex: the raw ethereum transaction in hexadecimal to sign
      * @param resolution: resolution is an object with all "resolved" metadata necessary to allow the device to clear sign information. This includes: ERC20 token information, plugins, contracts, NFT signatures,... You must explicitly provide something to avoid having a warning. By default, you can use Ledger's service or your own resolution service. See services/types.js for the contract. Setting the value to "null" will fallback everything to blind signing but will still allow the device to sign the transaction.
      * @example
@@ -151,7 +150,7 @@ var Eth = /** @class */ (function () {
      const result = eth.signTransaction("44'/60'/0'/0/0", tx, resolution);
      console.log(result);
      */
-    Eth.prototype.signTransaction = function (path, rawTxHex, resolution) {
+    Eth.prototype.signTransaction = function (paths, rawTxHex, resolution) {
         return __awaiter(this, void 0, void 0, function () {
             var _a, _b, plugin, e_1_1, _c, _d, _e, payload, signature, e_2_1, _f, _g, nft, e_3_1, _h, _j, data, e_4_1, rawTx, _k, vrsOffset, txType, chainId, chainIdTruncated, paths, response, offset, _loop_1, this_1, response_byte, v, oneByteChainId, ecc_parity, r, s;
             var e_1, _l, e_2, _m, e_3, _o, e_4, _p;
@@ -284,7 +283,6 @@ var Eth = /** @class */ (function () {
                     case 31:
                         rawTx = Buffer.from(rawTxHex, "hex");
                         _k = decodeTxInfo(rawTx), vrsOffset = _k.vrsOffset, txType = _k.txType, chainId = _k.chainId, chainIdTruncated = _k.chainIdTruncated;                        
-                        paths = splitPath(path);
                         offset = 0;
                         _loop_1 = function () {
                             var first, maxChunkSize, chunkSize, buffer;
@@ -362,7 +360,7 @@ var Eth = /** @class */ (function () {
     /**
      * Helper to get resolution and signature of a transaction in a single method
      *
-     * @param path: the BIP32 path to sign the transaction on
+     * @param paths: the BIP32 path to sign the transaction on
      * @param rawTxHex: the raw ethereum transaction in hexadecimal to sign
      * @param resolutionConfig: configuration about what should be clear signed in the transaction
      * @param throwOnError: optional parameter to determine if a failing resolution of the transaction should throw an error or not
@@ -371,7 +369,7 @@ var Eth = /** @class */ (function () {
      const result = eth.clearSignTransaction("44'/60'/0'/0/0", tx, { erc20: true, externalPlugins: true, nft: true});
      console.log(result);
      */
-    Eth.prototype.clearSignTransaction = function (path, rawTxHex, resolutionConfig, throwOnError) {
+    Eth.prototype.clearSignTransaction = function (paths, rawTxHex, resolutionConfig, throwOnError) {
         if (throwOnError === void 0) { throwOnError = false; }
         return __awaiter(this, void 0, void 0, function () {
             var resolution;
@@ -388,7 +386,7 @@ var Eth = /** @class */ (function () {
                         })];
                     case 1:
                         resolution = _a.sent();
-                        return [2 /*return*/, this.signTransaction(path, rawTxHex, resolution)];
+                        return [2 /*return*/, this.signTransaction(paths, rawTxHex, resolution)];
                 }
             });
         });
diff --git a/node_modules/@ledgerhq/hw-app-eth/lib/Eth.d.ts b/node_modules/@ledgerhq/hw-app-eth/lib/Eth.d.ts
index c77df2e..0d3521c 100644
--- a/node_modules/@ledgerhq/hw-app-eth/lib/Eth.d.ts
+++ b/node_modules/@ledgerhq/hw-app-eth/lib/Eth.d.ts
@@ -36,14 +36,14 @@ export default class Eth {
     constructor(transport: Transport, scrambleKey?: string, loadConfig?: LoadConfig);
     /**
      * get Ethereum address for a given BIP 32 path.
-     * @param path a path in BIP 32 format
+     * @param paths a path in BIP 32 format
      * @option boolDisplay optionally enable or not the display
      * @option boolChaincode optionally enable or not the chaincode request
      * @return an object with a publicKey, address and (optionally) chainCode
      * @example
      * eth.getAddress("44'/60'/0'/0/0").then(o => o.address)
      */
-    getAddress(path: string, boolDisplay?: boolean, boolChaincode?: boolean): Promise<{
+    getAddress(paths: number[], boolDisplay?: boolean, boolChaincode?: boolean): Promise<{
         publicKey: string;
         address: string;
         chainCode?: string;
@@ -51,7 +51,7 @@ export default class Eth {
     /**
      * You can sign a transaction and retrieve v, r, s given the raw transaction and the BIP 32 path of the account to sign.
      *
-     * @param path: the BIP32 path to sign the transaction on
+     * @param paths: the BIP32 path to sign the transaction on
      * @param rawTxHex: the raw ethereum transaction in hexadecimal to sign
      * @param resolution: resolution is an object with all "resolved" metadata necessary to allow the device to clear sign information. This includes: ERC20 token information, plugins, contracts, NFT signatures,... You must explicitly provide something to avoid having a warning. By default, you can use Ledger's service or your own resolution service. See services/types.js for the contract. Setting the value to "null" will fallback everything to blind signing but will still allow the device to sign the transaction.
      * @example
@@ -61,7 +61,7 @@ export default class Eth {
      const result = eth.signTransaction("44'/60'/0'/0/0", tx, resolution);
      console.log(result);
      */
-    signTransaction(path: string, rawTxHex: string, resolution?: LedgerEthTransactionResolution | null): Promise<{
+    signTransaction(paths: number[], rawTxHex: string, resolution?: LedgerEthTransactionResolution | null): Promise<{
         s: string;
         v: string;
         r: string;
@@ -69,7 +69,7 @@ export default class Eth {
     /**
      * Helper to get resolution and signature of a transaction in a single method
      *
-     * @param path: the BIP32 path to sign the transaction on
+     * @param paths: the BIP32 path to sign the transaction on
      * @param rawTxHex: the raw ethereum transaction in hexadecimal to sign
      * @param resolutionConfig: configuration about what should be clear signed in the transaction
      * @param throwOnError: optional parameter to determine if a failing resolution of the transaction should throw an error or not
@@ -78,7 +78,7 @@ export default class Eth {
      const result = eth.clearSignTransaction("44'/60'/0'/0/0", tx, { erc20: true, externalPlugins: true, nft: true});
      console.log(result);
      */
-    clearSignTransaction(path: string, rawTxHex: string, resolutionConfig: ResolutionConfig, throwOnError?: boolean): Promise<{
+    clearSignTransaction(paths: number[], rawTxHex: string, resolutionConfig: ResolutionConfig, throwOnError?: boolean): Promise<{
         r: string;
         s: string;
         v: string;
diff --git a/node_modules/@ledgerhq/hw-app-eth/lib/Eth.js b/node_modules/@ledgerhq/hw-app-eth/lib/Eth.js
index d865941..3c656f8 100644
--- a/node_modules/@ledgerhq/hw-app-eth/lib/Eth.js
+++ b/node_modules/@ledgerhq/hw-app-eth/lib/Eth.js
@@ -113,15 +113,14 @@ var Eth = /** @class */ (function () {
     };
     /**
      * get Ethereum address for a given BIP 32 path.
-     * @param path a path in BIP 32 format
+     * @param paths a path in BIP 32 format
      * @option boolDisplay optionally enable or not the display
      * @option boolChaincode optionally enable or not the chaincode request
      * @return an object with a publicKey, address and (optionally) chainCode
      * @example
      * eth.getAddress("44'/60'/0'/0/0").then(o => o.address)
      */
-    Eth.prototype.getAddress = function (path, boolDisplay, boolChaincode) {
-        var paths = (0, utils_1.splitPath)(path);
+    Eth.prototype.getAddress = function (paths, boolDisplay, boolChaincode) {        
         var buffer = Buffer.alloc(1 + paths.length * 4);
         buffer[0] = paths.length;
         paths.forEach(function (element, index) {
@@ -149,7 +148,7 @@ var Eth = /** @class */ (function () {
     /**
      * You can sign a transaction and retrieve v, r, s given the raw transaction and the BIP 32 path of the account to sign.
      *
-     * @param path: the BIP32 path to sign the transaction on
+     * @param paths: the BIP32 path to sign the transaction on
      * @param rawTxHex: the raw ethereum transaction in hexadecimal to sign
      * @param resolution: resolution is an object with all "resolved" metadata necessary to allow the device to clear sign information. This includes: ERC20 token information, plugins, contracts, NFT signatures,... You must explicitly provide something to avoid having a warning. By default, you can use Ledger's service or your own resolution service. See services/types.js for the contract. Setting the value to "null" will fallback everything to blind signing but will still allow the device to sign the transaction.
      * @example
@@ -159,7 +158,7 @@ var Eth = /** @class */ (function () {
      const result = eth.signTransaction("44'/60'/0'/0/0", tx, resolution);
      console.log(result);
      */
-    Eth.prototype.signTransaction = function (path, rawTxHex, resolution) {
+    Eth.prototype.signTransaction = function (paths, rawTxHex, resolution) {
         return __awaiter(this, void 0, void 0, function () {
             var _a, _b, plugin, e_1_1, _c, _d, _e, payload, signature, e_2_1, _f, _g, nft, e_3_1, _h, _j, data, e_4_1, rawTx, _k, vrsOffset, txType, chainId, chainIdTruncated, paths, response, offset, _loop_1, this_1, response_byte, v, oneByteChainId, ecc_parity, r, s;
             var e_1, _l, e_2, _m, e_3, _o, e_4, _p;
@@ -292,7 +291,6 @@ var Eth = /** @class */ (function () {
                     case 31:
                         rawTx = Buffer.from(rawTxHex, "hex");
                         _k = (0, utils_1.decodeTxInfo)(rawTx), vrsOffset = _k.vrsOffset, txType = _k.txType, chainId = _k.chainId, chainIdTruncated = _k.chainIdTruncated;                        
-                        paths = (0, utils_1.splitPath)(path);
                         offset = 0;
                         _loop_1 = function () {
                             var first, maxChunkSize, chunkSize, buffer;
@@ -370,7 +368,7 @@ var Eth = /** @class */ (function () {
     /**
      * Helper to get resolution and signature of a transaction in a single method
      *
-     * @param path: the BIP32 path to sign the transaction on
+     * @param paths: the BIP32 path to sign the transaction on
      * @param rawTxHex: the raw ethereum transaction in hexadecimal to sign
      * @param resolutionConfig: configuration about what should be clear signed in the transaction
      * @param throwOnError: optional parameter to determine if a failing resolution of the transaction should throw an error or not
@@ -379,7 +377,7 @@ var Eth = /** @class */ (function () {
      const result = eth.clearSignTransaction("44'/60'/0'/0/0", tx, { erc20: true, externalPlugins: true, nft: true});
      console.log(result);
      */
-    Eth.prototype.clearSignTransaction = function (path, rawTxHex, resolutionConfig, throwOnError) {
+    Eth.prototype.clearSignTransaction = function (paths, rawTxHex, resolutionConfig, throwOnError) {
         if (throwOnError === void 0) { throwOnError = false; }
         return __awaiter(this, void 0, void 0, function () {
             var resolution;
@@ -396,7 +394,7 @@ var Eth = /** @class */ (function () {
                         })];
                     case 1:
                         resolution = _a.sent();
-                        return [2 /*return*/, this.signTransaction(path, rawTxHex, resolution)];
+                        return [2 /*return*/, this.signTransaction(paths, rawTxHex, resolution)];
                 }
             });
         });
diff --git a/node_modules/@ledgerhq/hw-app-eth/lib/modules/EIP712/EIP712.utils.js b/node_modules/@ledgerhq/hw-app-eth/lib/modules/EIP712/EIP712.utils.js
index 2aa2d39..1da9703 100644
--- a/node_modules/@ledgerhq/hw-app-eth/lib/modules/EIP712/EIP712.utils.js
+++ b/node_modules/@ledgerhq/hw-app-eth/lib/modules/EIP712/EIP712.utils.js
@@ -68,7 +68,7 @@ exports.getFiltersForMessage = exports.getSchemaHashForMessage = exports.sortObj
 var axios_1 = __importDefault(require("axios"));
 var sha224_1 = __importDefault(require("crypto-js/sha224"));
 var utils_1 = require("../../utils");
-var eip712_1 = __importDefault(require("@ledgerhq/cryptoassets/data/eip712"));
+var eip712_1 = __importDefault(require("@ledgerhq/cryptoassets/lib/data/eip712"));
 var bignumber_js_1 = __importDefault(require("bignumber.js"));
 var NULL_ADDRESS = "0x0000000000000000000000000000000000000000";
 /**
diff --git a/node_modules/@ledgerhq/hw-app-eth/lib/services/ledger/erc20.js b/node_modules/@ledgerhq/hw-app-eth/lib/services/ledger/erc20.js
index 5d1643b..35eb8f2 100644
--- a/node_modules/@ledgerhq/hw-app-eth/lib/services/ledger/erc20.js
+++ b/node_modules/@ledgerhq/hw-app-eth/lib/services/ledger/erc20.js
@@ -42,7 +42,7 @@ exports.__esModule = true;
 exports.byContractAddressAndChainId = exports.findERC20SignaturesInfo = void 0;
 var axios_1 = __importDefault(require("axios"));
 var logs_1 = require("@ledgerhq/logs");
-var index_1 = require("@ledgerhq/cryptoassets/data/evm/index");
+var index_1 = require("@ledgerhq/cryptoassets/lib/data/evm/index");
 var loadConfig_1 = require("./loadConfig");
 var asContractAddress = function (addr) {
     var a = addr.toLowerCase();
diff --git a/node_modules/@ledgerhq/hw-app-eth/src/Eth.ts b/node_modules/@ledgerhq/hw-app-eth/src/Eth.ts
index d2e7c8c..905096f 100644
--- a/node_modules/@ledgerhq/hw-app-eth/src/Eth.ts
+++ b/node_modules/@ledgerhq/hw-app-eth/src/Eth.ts
@@ -117,15 +117,15 @@ export default class Eth {
 
   /**
    * get Ethereum address for a given BIP 32 path.
-   * @param path a path in BIP 32 format
+   * @param paths a path in BIP 32 format
    * @option boolDisplay optionally enable or not the display
    * @option boolChaincode optionally enable or not the chaincode request
    * @return an object with a publicKey, address and (optionally) chainCode
    * @example
    * eth.getAddress("44'/60'/0'/0/0").then(o => o.address)
    */
-  getAddress(
-    path: string,
+  async getAddress(
+    paths: number[],
     boolDisplay?: boolean,
     boolChaincode?: boolean
   ): Promise<{
@@ -133,7 +133,6 @@ export default class Eth {
     address: string;
     chainCode?: string;
   }> {    
-    const paths = splitPath(path);
     const buffer = Buffer.alloc(1 + paths.length * 4);
     buffer[0] = paths.length;
     paths.forEach((element, index) => {
@@ -176,7 +175,7 @@ export default class Eth {
   /**
    * You can sign a transaction and retrieve v, r, s given the raw transaction and the BIP 32 path of the account to sign.
    *
-   * @param path: the BIP32 path to sign the transaction on
+   * @param paths: the BIP32 path to sign the transaction on
    * @param rawTxHex: the raw ethereum transaction in hexadecimal to sign
    * @param resolution: resolution is an object with all "resolved" metadata necessary to allow the device to clear sign information. This includes: ERC20 token information, plugins, contracts, NFT signatures,... You must explicitly provide something to avoid having a warning. By default, you can use Ledger's service or your own resolution service. See services/types.js for the contract. Setting the value to "null" will fallback everything to blind signing but will still allow the device to sign the transaction.
    * @example
@@ -187,7 +186,7 @@ export default class Eth {
    console.log(result);
    */
   async signTransaction(
-    path: string,
+    paths: number[],
     rawTxHex: string,
     resolution?: LedgerEthTransactionResolution | null
   ): Promise<{
@@ -242,7 +241,6 @@ export default class Eth {
     const { vrsOffset, txType, chainId, chainIdTruncated } =
       decodeTxInfo(rawTx);
     
-    const paths = splitPath(path);
     let response;
     let offset = 0;
     while (offset !== rawTx.length) {
@@ -313,7 +311,7 @@ export default class Eth {
   /**
    * Helper to get resolution and signature of a transaction in a single method
    * 
-   * @param path: the BIP32 path to sign the transaction on
+   * @param paths: the BIP32 path to sign the transaction on
    * @param rawTxHex: the raw ethereum transaction in hexadecimal to sign
    * @param resolutionConfig: configuration about what should be clear signed in the transaction
    * @param throwOnError: optional parameter to determine if a failing resolution of the transaction should throw an error or not
@@ -323,7 +321,7 @@ export default class Eth {
    console.log(result);
    */
   async clearSignTransaction(
-    path: string,
+    paths: number[],
     rawTxHex: string,
     resolutionConfig: ResolutionConfig,
     throwOnError = false
@@ -342,7 +340,7 @@ export default class Eth {
         return null;
       });
 
-    return this.signTransaction(path, rawTxHex, resolution);
+    return this.signTransaction(paths, rawTxHex, resolution);
   }
 
   /**